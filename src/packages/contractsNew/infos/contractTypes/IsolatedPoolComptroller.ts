/* Autogenerated file. Do not edit manually. */

/* tslint:disable */

/* eslint-disable */
import type { EventFragment, FunctionFragment, Result } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';

import type { OnEvent, TypedEvent, TypedEventFilter, TypedListener } from './common';

export declare namespace ComptrollerStorage {
  export type RewardSpeedsStruct = {
    rewardToken: string;
    supplySpeed: BigNumberish;
    borrowSpeed: BigNumberish;
  };

  export type RewardSpeedsStructOutput = [string, BigNumber, BigNumber] & {
    rewardToken: string;
    supplySpeed: BigNumber;
    borrowSpeed: BigNumber;
  };

  export type LiquidationOrderStruct = {
    vTokenCollateral: string;
    vTokenBorrowed: string;
    repayAmount: BigNumberish;
  };

  export type LiquidationOrderStructOutput = [string, string, BigNumber] & {
    vTokenCollateral: string;
    vTokenBorrowed: string;
    repayAmount: BigNumber;
  };
}

export interface IsolatedPoolComptrollerInterface extends utils.Interface {
  functions: {
    'acceptOwnership()': FunctionFragment;
    'accessControlManager()': FunctionFragment;
    'accountAssets(address,uint256)': FunctionFragment;
    'actionPaused(address,uint8)': FunctionFragment;
    'addRewardsDistributor(address)': FunctionFragment;
    'allMarkets(uint256)': FunctionFragment;
    'borrowCaps(address)': FunctionFragment;
    'checkMembership(address,address)': FunctionFragment;
    'closeFactorMantissa()': FunctionFragment;
    'enterMarkets(address[])': FunctionFragment;
    'exitMarket(address)': FunctionFragment;
    'getAccountLiquidity(address)': FunctionFragment;
    'getAllMarkets()': FunctionFragment;
    'getAssetsIn(address)': FunctionFragment;
    'getBorrowingPower(address)': FunctionFragment;
    'getHypotheticalAccountLiquidity(address,address,uint256,uint256)': FunctionFragment;
    'getRewardDistributors()': FunctionFragment;
    'getRewardsByMarket(address)': FunctionFragment;
    'healAccount(address)': FunctionFragment;
    'initialize(uint256,address)': FunctionFragment;
    'isComptroller()': FunctionFragment;
    'isDeprecated(address)': FunctionFragment;
    'isMarketListed(address)': FunctionFragment;
    'liquidateAccount(address,(address,address,uint256)[])': FunctionFragment;
    'liquidateCalculateSeizeTokens(address,address,uint256)': FunctionFragment;
    'liquidationIncentiveMantissa()': FunctionFragment;
    'markets(address)': FunctionFragment;
    'maxLoopsLimit()': FunctionFragment;
    'minLiquidatableCollateral()': FunctionFragment;
    'oracle()': FunctionFragment;
    'owner()': FunctionFragment;
    'pendingOwner()': FunctionFragment;
    'poolRegistry()': FunctionFragment;
    'preBorrowHook(address,address,uint256)': FunctionFragment;
    'preLiquidateHook(address,address,address,uint256,bool)': FunctionFragment;
    'preMintHook(address,address,uint256)': FunctionFragment;
    'preRedeemHook(address,address,uint256)': FunctionFragment;
    'preRepayHook(address,address)': FunctionFragment;
    'preSeizeHook(address,address,address,address)': FunctionFragment;
    'preTransferHook(address,address,address,uint256)': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'setAccessControlManager(address)': FunctionFragment;
    'setActionsPaused(address[],uint8[],bool)': FunctionFragment;
    'setCloseFactor(uint256)': FunctionFragment;
    'setCollateralFactor(address,uint256,uint256)': FunctionFragment;
    'setLiquidationIncentive(uint256)': FunctionFragment;
    'setMarketBorrowCaps(address[],uint256[])': FunctionFragment;
    'setMarketSupplyCaps(address[],uint256[])': FunctionFragment;
    'setMaxLoopsLimit(uint256)': FunctionFragment;
    'setMinLiquidatableCollateral(uint256)': FunctionFragment;
    'setPriceOracle(address)': FunctionFragment;
    'supplyCaps(address)': FunctionFragment;
    'supportMarket(address)': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'updatePrices(address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'acceptOwnership'
      | 'accessControlManager'
      | 'accountAssets'
      | 'actionPaused'
      | 'addRewardsDistributor'
      | 'allMarkets'
      | 'borrowCaps'
      | 'checkMembership'
      | 'closeFactorMantissa'
      | 'enterMarkets'
      | 'exitMarket'
      | 'getAccountLiquidity'
      | 'getAllMarkets'
      | 'getAssetsIn'
      | 'getBorrowingPower'
      | 'getHypotheticalAccountLiquidity'
      | 'getRewardDistributors'
      | 'getRewardsByMarket'
      | 'healAccount'
      | 'initialize'
      | 'isComptroller'
      | 'isDeprecated'
      | 'isMarketListed'
      | 'liquidateAccount'
      | 'liquidateCalculateSeizeTokens'
      | 'liquidationIncentiveMantissa'
      | 'markets'
      | 'maxLoopsLimit'
      | 'minLiquidatableCollateral'
      | 'oracle'
      | 'owner'
      | 'pendingOwner'
      | 'poolRegistry'
      | 'preBorrowHook'
      | 'preLiquidateHook'
      | 'preMintHook'
      | 'preRedeemHook'
      | 'preRepayHook'
      | 'preSeizeHook'
      | 'preTransferHook'
      | 'renounceOwnership'
      | 'setAccessControlManager'
      | 'setActionsPaused'
      | 'setCloseFactor'
      | 'setCollateralFactor'
      | 'setLiquidationIncentive'
      | 'setMarketBorrowCaps'
      | 'setMarketSupplyCaps'
      | 'setMaxLoopsLimit'
      | 'setMinLiquidatableCollateral'
      | 'setPriceOracle'
      | 'supplyCaps'
      | 'supportMarket'
      | 'transferOwnership'
      | 'updatePrices',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'acceptOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'accessControlManager', values?: undefined): string;
  encodeFunctionData(functionFragment: 'accountAssets', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'actionPaused', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'addRewardsDistributor', values: [string]): string;
  encodeFunctionData(functionFragment: 'allMarkets', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'borrowCaps', values: [string]): string;
  encodeFunctionData(functionFragment: 'checkMembership', values: [string, string]): string;
  encodeFunctionData(functionFragment: 'closeFactorMantissa', values?: undefined): string;
  encodeFunctionData(functionFragment: 'enterMarkets', values: [string[]]): string;
  encodeFunctionData(functionFragment: 'exitMarket', values: [string]): string;
  encodeFunctionData(functionFragment: 'getAccountLiquidity', values: [string]): string;
  encodeFunctionData(functionFragment: 'getAllMarkets', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getAssetsIn', values: [string]): string;
  encodeFunctionData(functionFragment: 'getBorrowingPower', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'getHypotheticalAccountLiquidity',
    values: [string, string, BigNumberish, BigNumberish],
  ): string;
  encodeFunctionData(functionFragment: 'getRewardDistributors', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getRewardsByMarket', values: [string]): string;
  encodeFunctionData(functionFragment: 'healAccount', values: [string]): string;
  encodeFunctionData(functionFragment: 'initialize', values: [BigNumberish, string]): string;
  encodeFunctionData(functionFragment: 'isComptroller', values?: undefined): string;
  encodeFunctionData(functionFragment: 'isDeprecated', values: [string]): string;
  encodeFunctionData(functionFragment: 'isMarketListed', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'liquidateAccount',
    values: [string, ComptrollerStorage.LiquidationOrderStruct[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'liquidateCalculateSeizeTokens',
    values: [string, string, BigNumberish],
  ): string;
  encodeFunctionData(functionFragment: 'liquidationIncentiveMantissa', values?: undefined): string;
  encodeFunctionData(functionFragment: 'markets', values: [string]): string;
  encodeFunctionData(functionFragment: 'maxLoopsLimit', values?: undefined): string;
  encodeFunctionData(functionFragment: 'minLiquidatableCollateral', values?: undefined): string;
  encodeFunctionData(functionFragment: 'oracle', values?: undefined): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingOwner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'poolRegistry', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'preBorrowHook',
    values: [string, string, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'preLiquidateHook',
    values: [string, string, string, BigNumberish, boolean],
  ): string;
  encodeFunctionData(
    functionFragment: 'preMintHook',
    values: [string, string, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'preRedeemHook',
    values: [string, string, BigNumberish],
  ): string;
  encodeFunctionData(functionFragment: 'preRepayHook', values: [string, string]): string;
  encodeFunctionData(
    functionFragment: 'preSeizeHook',
    values: [string, string, string, string],
  ): string;
  encodeFunctionData(
    functionFragment: 'preTransferHook',
    values: [string, string, string, BigNumberish],
  ): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setAccessControlManager', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'setActionsPaused',
    values: [string[], BigNumberish[], boolean],
  ): string;
  encodeFunctionData(functionFragment: 'setCloseFactor', values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: 'setCollateralFactor',
    values: [string, BigNumberish, BigNumberish],
  ): string;
  encodeFunctionData(functionFragment: 'setLiquidationIncentive', values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: 'setMarketBorrowCaps',
    values: [string[], BigNumberish[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'setMarketSupplyCaps',
    values: [string[], BigNumberish[]],
  ): string;
  encodeFunctionData(functionFragment: 'setMaxLoopsLimit', values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: 'setMinLiquidatableCollateral',
    values: [BigNumberish],
  ): string;
  encodeFunctionData(functionFragment: 'setPriceOracle', values: [string]): string;
  encodeFunctionData(functionFragment: 'supplyCaps', values: [string]): string;
  encodeFunctionData(functionFragment: 'supportMarket', values: [string]): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [string]): string;
  encodeFunctionData(functionFragment: 'updatePrices', values: [string]): string;

  decodeFunctionResult(functionFragment: 'acceptOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'accessControlManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'accountAssets', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'actionPaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addRewardsDistributor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allMarkets', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'borrowCaps', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkMembership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'closeFactorMantissa', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'enterMarkets', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exitMarket', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAccountLiquidity', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAllMarkets', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAssetsIn', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getBorrowingPower', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'getHypotheticalAccountLiquidity',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'getRewardDistributors', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRewardsByMarket', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'healAccount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isComptroller', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isDeprecated', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isMarketListed', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidateAccount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidateCalculateSeizeTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'liquidationIncentiveMantissa', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'markets', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'maxLoopsLimit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minLiquidatableCollateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'oracle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingOwner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'poolRegistry', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'preBorrowHook', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'preLiquidateHook', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'preMintHook', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'preRedeemHook', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'preRepayHook', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'preSeizeHook', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'preTransferHook', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setAccessControlManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setActionsPaused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setCloseFactor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setCollateralFactor', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setLiquidationIncentive', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMarketBorrowCaps', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMarketSupplyCaps', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMaxLoopsLimit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMinLiquidatableCollateral', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setPriceOracle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'supplyCaps', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'supportMarket', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updatePrices', data: BytesLike): Result;

  events: {
    'ActionPausedMarket(address,uint8,bool)': EventFragment;
    'Initialized(uint8)': EventFragment;
    'MarketEntered(address,address)': EventFragment;
    'MarketExited(address,address)': EventFragment;
    'MarketSupported(address)': EventFragment;
    'MaxLoopsLimitUpdated(uint256,uint256)': EventFragment;
    'NewAccessControlManager(address,address)': EventFragment;
    'NewBorrowCap(address,uint256)': EventFragment;
    'NewCloseFactor(uint256,uint256)': EventFragment;
    'NewCollateralFactor(address,uint256,uint256)': EventFragment;
    'NewLiquidationIncentive(uint256,uint256)': EventFragment;
    'NewLiquidationThreshold(address,uint256,uint256)': EventFragment;
    'NewMinLiquidatableCollateral(uint256,uint256)': EventFragment;
    'NewPriceOracle(address,address)': EventFragment;
    'NewRewardsDistributor(address)': EventFragment;
    'NewSupplyCap(address,uint256)': EventFragment;
    'OwnershipTransferStarted(address,address)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'ActionPausedMarket'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Initialized'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MarketEntered'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MarketExited'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MarketSupported'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MaxLoopsLimitUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewAccessControlManager'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewBorrowCap'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewCloseFactor'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewCollateralFactor'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewLiquidationIncentive'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewLiquidationThreshold'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewMinLiquidatableCollateral'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewPriceOracle'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewRewardsDistributor'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewSupplyCap'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferStarted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
}

export interface ActionPausedMarketEventObject {
  vToken: string;
  action: number;
  pauseState: boolean;
}
export type ActionPausedMarketEvent = TypedEvent<
  [string, number, boolean],
  ActionPausedMarketEventObject
>;

export type ActionPausedMarketEventFilter = TypedEventFilter<ActionPausedMarketEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface MarketEnteredEventObject {
  vToken: string;
  account: string;
}
export type MarketEnteredEvent = TypedEvent<[string, string], MarketEnteredEventObject>;

export type MarketEnteredEventFilter = TypedEventFilter<MarketEnteredEvent>;

export interface MarketExitedEventObject {
  vToken: string;
  account: string;
}
export type MarketExitedEvent = TypedEvent<[string, string], MarketExitedEventObject>;

export type MarketExitedEventFilter = TypedEventFilter<MarketExitedEvent>;

export interface MarketSupportedEventObject {
  vToken: string;
}
export type MarketSupportedEvent = TypedEvent<[string], MarketSupportedEventObject>;

export type MarketSupportedEventFilter = TypedEventFilter<MarketSupportedEvent>;

export interface MaxLoopsLimitUpdatedEventObject {
  oldMaxLoopsLimit: BigNumber;
  newmaxLoopsLimit: BigNumber;
}
export type MaxLoopsLimitUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber],
  MaxLoopsLimitUpdatedEventObject
>;

export type MaxLoopsLimitUpdatedEventFilter = TypedEventFilter<MaxLoopsLimitUpdatedEvent>;

export interface NewAccessControlManagerEventObject {
  oldAccessControlManager: string;
  newAccessControlManager: string;
}
export type NewAccessControlManagerEvent = TypedEvent<
  [string, string],
  NewAccessControlManagerEventObject
>;

export type NewAccessControlManagerEventFilter = TypedEventFilter<NewAccessControlManagerEvent>;

export interface NewBorrowCapEventObject {
  vToken: string;
  newBorrowCap: BigNumber;
}
export type NewBorrowCapEvent = TypedEvent<[string, BigNumber], NewBorrowCapEventObject>;

export type NewBorrowCapEventFilter = TypedEventFilter<NewBorrowCapEvent>;

export interface NewCloseFactorEventObject {
  oldCloseFactorMantissa: BigNumber;
  newCloseFactorMantissa: BigNumber;
}
export type NewCloseFactorEvent = TypedEvent<[BigNumber, BigNumber], NewCloseFactorEventObject>;

export type NewCloseFactorEventFilter = TypedEventFilter<NewCloseFactorEvent>;

export interface NewCollateralFactorEventObject {
  vToken: string;
  oldCollateralFactorMantissa: BigNumber;
  newCollateralFactorMantissa: BigNumber;
}
export type NewCollateralFactorEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  NewCollateralFactorEventObject
>;

export type NewCollateralFactorEventFilter = TypedEventFilter<NewCollateralFactorEvent>;

export interface NewLiquidationIncentiveEventObject {
  oldLiquidationIncentiveMantissa: BigNumber;
  newLiquidationIncentiveMantissa: BigNumber;
}
export type NewLiquidationIncentiveEvent = TypedEvent<
  [BigNumber, BigNumber],
  NewLiquidationIncentiveEventObject
>;

export type NewLiquidationIncentiveEventFilter = TypedEventFilter<NewLiquidationIncentiveEvent>;

export interface NewLiquidationThresholdEventObject {
  vToken: string;
  oldLiquidationThresholdMantissa: BigNumber;
  newLiquidationThresholdMantissa: BigNumber;
}
export type NewLiquidationThresholdEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  NewLiquidationThresholdEventObject
>;

export type NewLiquidationThresholdEventFilter = TypedEventFilter<NewLiquidationThresholdEvent>;

export interface NewMinLiquidatableCollateralEventObject {
  oldMinLiquidatableCollateral: BigNumber;
  newMinLiquidatableCollateral: BigNumber;
}
export type NewMinLiquidatableCollateralEvent = TypedEvent<
  [BigNumber, BigNumber],
  NewMinLiquidatableCollateralEventObject
>;

export type NewMinLiquidatableCollateralEventFilter =
  TypedEventFilter<NewMinLiquidatableCollateralEvent>;

export interface NewPriceOracleEventObject {
  oldPriceOracle: string;
  newPriceOracle: string;
}
export type NewPriceOracleEvent = TypedEvent<[string, string], NewPriceOracleEventObject>;

export type NewPriceOracleEventFilter = TypedEventFilter<NewPriceOracleEvent>;

export interface NewRewardsDistributorEventObject {
  rewardsDistributor: string;
}
export type NewRewardsDistributorEvent = TypedEvent<[string], NewRewardsDistributorEventObject>;

export type NewRewardsDistributorEventFilter = TypedEventFilter<NewRewardsDistributorEvent>;

export interface NewSupplyCapEventObject {
  vToken: string;
  newSupplyCap: BigNumber;
}
export type NewSupplyCapEvent = TypedEvent<[string, BigNumber], NewSupplyCapEventObject>;

export type NewSupplyCapEventFilter = TypedEventFilter<NewSupplyCapEvent>;

export interface OwnershipTransferStartedEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferStartedEvent = TypedEvent<
  [string, string],
  OwnershipTransferStartedEventObject
>;

export type OwnershipTransferStartedEventFilter = TypedEventFilter<OwnershipTransferStartedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface IsolatedPoolComptroller extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IsolatedPoolComptrollerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>,
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    acceptOwnership(overrides?: Overrides & { from?: string }): Promise<ContractTransaction>;

    accessControlManager(overrides?: CallOverrides): Promise<[string]>;

    accountAssets(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    actionPaused(
      market: string,
      action: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    addRewardsDistributor(
      _rewardsDistributor: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    allMarkets(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    borrowCaps(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    checkMembership(account: string, vToken: string, overrides?: CallOverrides): Promise<[boolean]>;

    closeFactorMantissa(overrides?: CallOverrides): Promise<[BigNumber]>;

    enterMarkets(
      vTokens: string[],
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    exitMarket(
      vTokenAddress: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    getAccountLiquidity(
      account: string,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        error: BigNumber;
        liquidity: BigNumber;
        shortfall: BigNumber;
      }
    >;

    getAllMarkets(overrides?: CallOverrides): Promise<[string[]]>;

    getAssetsIn(account: string, overrides?: CallOverrides): Promise<[string[]]>;

    getBorrowingPower(
      account: string,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        error: BigNumber;
        liquidity: BigNumber;
        shortfall: BigNumber;
      }
    >;

    getHypotheticalAccountLiquidity(
      account: string,
      vTokenModify: string,
      redeemTokens: BigNumberish,
      borrowAmount: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        error: BigNumber;
        liquidity: BigNumber;
        shortfall: BigNumber;
      }
    >;

    getRewardDistributors(overrides?: CallOverrides): Promise<[string[]]>;

    getRewardsByMarket(
      vToken: string,
      overrides?: CallOverrides,
    ): Promise<
      [ComptrollerStorage.RewardSpeedsStructOutput[]] & {
        rewardSpeeds: ComptrollerStorage.RewardSpeedsStructOutput[];
      }
    >;

    healAccount(
      user: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    initialize(
      loopLimit: BigNumberish,
      accessControlManager: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    isComptroller(overrides?: CallOverrides): Promise<[boolean]>;

    isDeprecated(vToken: string, overrides?: CallOverrides): Promise<[boolean]>;

    isMarketListed(vToken: string, overrides?: CallOverrides): Promise<[boolean]>;

    liquidateAccount(
      borrower: string,
      orders: ComptrollerStorage.LiquidationOrderStruct[],
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    liquidateCalculateSeizeTokens(
      vTokenBorrowed: string,
      vTokenCollateral: string,
      actualRepayAmount: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { error: BigNumber; tokensToSeize: BigNumber }>;

    liquidationIncentiveMantissa(overrides?: CallOverrides): Promise<[BigNumber]>;

    markets(
      arg0: string,
      overrides?: CallOverrides,
    ): Promise<
      [boolean, BigNumber, BigNumber] & {
        isListed: boolean;
        collateralFactorMantissa: BigNumber;
        liquidationThresholdMantissa: BigNumber;
      }
    >;

    maxLoopsLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    minLiquidatableCollateral(overrides?: CallOverrides): Promise<[BigNumber]>;

    oracle(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pendingOwner(overrides?: CallOverrides): Promise<[string]>;

    poolRegistry(overrides?: CallOverrides): Promise<[string]>;

    preBorrowHook(
      vToken: string,
      borrower: string,
      borrowAmount: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    preLiquidateHook(
      vTokenBorrowed: string,
      vTokenCollateral: string,
      borrower: string,
      repayAmount: BigNumberish,
      skipLiquidityCheck: boolean,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    preMintHook(
      vToken: string,
      minter: string,
      mintAmount: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    preRedeemHook(
      vToken: string,
      redeemer: string,
      redeemTokens: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    preRepayHook(
      vToken: string,
      borrower: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    preSeizeHook(
      vTokenCollateral: string,
      seizerContract: string,
      liquidator: string,
      borrower: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    preTransferHook(
      vToken: string,
      src: string,
      dst: string,
      transferTokens: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: string }): Promise<ContractTransaction>;

    setAccessControlManager(
      accessControlManager_: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    setActionsPaused(
      marketsList: string[],
      actionsList: BigNumberish[],
      paused: boolean,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    setCloseFactor(
      newCloseFactorMantissa: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    setCollateralFactor(
      vToken: string,
      newCollateralFactorMantissa: BigNumberish,
      newLiquidationThresholdMantissa: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    setLiquidationIncentive(
      newLiquidationIncentiveMantissa: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    setMarketBorrowCaps(
      vTokens: string[],
      newBorrowCaps: BigNumberish[],
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    setMarketSupplyCaps(
      vTokens: string[],
      newSupplyCaps: BigNumberish[],
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    setMaxLoopsLimit(
      limit: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    setMinLiquidatableCollateral(
      newMinLiquidatableCollateral: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    setPriceOracle(
      newOracle: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    supplyCaps(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    supportMarket(
      vToken: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    updatePrices(
      account: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;
  };

  acceptOwnership(overrides?: Overrides & { from?: string }): Promise<ContractTransaction>;

  accessControlManager(overrides?: CallOverrides): Promise<string>;

  accountAssets(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<string>;

  actionPaused(market: string, action: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

  addRewardsDistributor(
    _rewardsDistributor: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  allMarkets(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  borrowCaps(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  checkMembership(account: string, vToken: string, overrides?: CallOverrides): Promise<boolean>;

  closeFactorMantissa(overrides?: CallOverrides): Promise<BigNumber>;

  enterMarkets(
    vTokens: string[],
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  exitMarket(
    vTokenAddress: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  getAccountLiquidity(
    account: string,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      error: BigNumber;
      liquidity: BigNumber;
      shortfall: BigNumber;
    }
  >;

  getAllMarkets(overrides?: CallOverrides): Promise<string[]>;

  getAssetsIn(account: string, overrides?: CallOverrides): Promise<string[]>;

  getBorrowingPower(
    account: string,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      error: BigNumber;
      liquidity: BigNumber;
      shortfall: BigNumber;
    }
  >;

  getHypotheticalAccountLiquidity(
    account: string,
    vTokenModify: string,
    redeemTokens: BigNumberish,
    borrowAmount: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      error: BigNumber;
      liquidity: BigNumber;
      shortfall: BigNumber;
    }
  >;

  getRewardDistributors(overrides?: CallOverrides): Promise<string[]>;

  getRewardsByMarket(
    vToken: string,
    overrides?: CallOverrides,
  ): Promise<ComptrollerStorage.RewardSpeedsStructOutput[]>;

  healAccount(
    user: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  initialize(
    loopLimit: BigNumberish,
    accessControlManager: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  isComptroller(overrides?: CallOverrides): Promise<boolean>;

  isDeprecated(vToken: string, overrides?: CallOverrides): Promise<boolean>;

  isMarketListed(vToken: string, overrides?: CallOverrides): Promise<boolean>;

  liquidateAccount(
    borrower: string,
    orders: ComptrollerStorage.LiquidationOrderStruct[],
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  liquidateCalculateSeizeTokens(
    vTokenBorrowed: string,
    vTokenCollateral: string,
    actualRepayAmount: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { error: BigNumber; tokensToSeize: BigNumber }>;

  liquidationIncentiveMantissa(overrides?: CallOverrides): Promise<BigNumber>;

  markets(
    arg0: string,
    overrides?: CallOverrides,
  ): Promise<
    [boolean, BigNumber, BigNumber] & {
      isListed: boolean;
      collateralFactorMantissa: BigNumber;
      liquidationThresholdMantissa: BigNumber;
    }
  >;

  maxLoopsLimit(overrides?: CallOverrides): Promise<BigNumber>;

  minLiquidatableCollateral(overrides?: CallOverrides): Promise<BigNumber>;

  oracle(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  pendingOwner(overrides?: CallOverrides): Promise<string>;

  poolRegistry(overrides?: CallOverrides): Promise<string>;

  preBorrowHook(
    vToken: string,
    borrower: string,
    borrowAmount: BigNumberish,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  preLiquidateHook(
    vTokenBorrowed: string,
    vTokenCollateral: string,
    borrower: string,
    repayAmount: BigNumberish,
    skipLiquidityCheck: boolean,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  preMintHook(
    vToken: string,
    minter: string,
    mintAmount: BigNumberish,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  preRedeemHook(
    vToken: string,
    redeemer: string,
    redeemTokens: BigNumberish,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  preRepayHook(
    vToken: string,
    borrower: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  preSeizeHook(
    vTokenCollateral: string,
    seizerContract: string,
    liquidator: string,
    borrower: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  preTransferHook(
    vToken: string,
    src: string,
    dst: string,
    transferTokens: BigNumberish,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  renounceOwnership(overrides?: Overrides & { from?: string }): Promise<ContractTransaction>;

  setAccessControlManager(
    accessControlManager_: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  setActionsPaused(
    marketsList: string[],
    actionsList: BigNumberish[],
    paused: boolean,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  setCloseFactor(
    newCloseFactorMantissa: BigNumberish,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  setCollateralFactor(
    vToken: string,
    newCollateralFactorMantissa: BigNumberish,
    newLiquidationThresholdMantissa: BigNumberish,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  setLiquidationIncentive(
    newLiquidationIncentiveMantissa: BigNumberish,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  setMarketBorrowCaps(
    vTokens: string[],
    newBorrowCaps: BigNumberish[],
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  setMarketSupplyCaps(
    vTokens: string[],
    newSupplyCaps: BigNumberish[],
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  setMaxLoopsLimit(
    limit: BigNumberish,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  setMinLiquidatableCollateral(
    newMinLiquidatableCollateral: BigNumberish,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  setPriceOracle(
    newOracle: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  supplyCaps(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  supportMarket(
    vToken: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  updatePrices(
    account: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  callStatic: {
    acceptOwnership(overrides?: CallOverrides): Promise<void>;

    accessControlManager(overrides?: CallOverrides): Promise<string>;

    accountAssets(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<string>;

    actionPaused(market: string, action: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

    addRewardsDistributor(_rewardsDistributor: string, overrides?: CallOverrides): Promise<void>;

    allMarkets(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    borrowCaps(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    checkMembership(account: string, vToken: string, overrides?: CallOverrides): Promise<boolean>;

    closeFactorMantissa(overrides?: CallOverrides): Promise<BigNumber>;

    enterMarkets(vTokens: string[], overrides?: CallOverrides): Promise<BigNumber[]>;

    exitMarket(vTokenAddress: string, overrides?: CallOverrides): Promise<BigNumber>;

    getAccountLiquidity(
      account: string,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        error: BigNumber;
        liquidity: BigNumber;
        shortfall: BigNumber;
      }
    >;

    getAllMarkets(overrides?: CallOverrides): Promise<string[]>;

    getAssetsIn(account: string, overrides?: CallOverrides): Promise<string[]>;

    getBorrowingPower(
      account: string,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        error: BigNumber;
        liquidity: BigNumber;
        shortfall: BigNumber;
      }
    >;

    getHypotheticalAccountLiquidity(
      account: string,
      vTokenModify: string,
      redeemTokens: BigNumberish,
      borrowAmount: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        error: BigNumber;
        liquidity: BigNumber;
        shortfall: BigNumber;
      }
    >;

    getRewardDistributors(overrides?: CallOverrides): Promise<string[]>;

    getRewardsByMarket(
      vToken: string,
      overrides?: CallOverrides,
    ): Promise<ComptrollerStorage.RewardSpeedsStructOutput[]>;

    healAccount(user: string, overrides?: CallOverrides): Promise<void>;

    initialize(
      loopLimit: BigNumberish,
      accessControlManager: string,
      overrides?: CallOverrides,
    ): Promise<void>;

    isComptroller(overrides?: CallOverrides): Promise<boolean>;

    isDeprecated(vToken: string, overrides?: CallOverrides): Promise<boolean>;

    isMarketListed(vToken: string, overrides?: CallOverrides): Promise<boolean>;

    liquidateAccount(
      borrower: string,
      orders: ComptrollerStorage.LiquidationOrderStruct[],
      overrides?: CallOverrides,
    ): Promise<void>;

    liquidateCalculateSeizeTokens(
      vTokenBorrowed: string,
      vTokenCollateral: string,
      actualRepayAmount: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { error: BigNumber; tokensToSeize: BigNumber }>;

    liquidationIncentiveMantissa(overrides?: CallOverrides): Promise<BigNumber>;

    markets(
      arg0: string,
      overrides?: CallOverrides,
    ): Promise<
      [boolean, BigNumber, BigNumber] & {
        isListed: boolean;
        collateralFactorMantissa: BigNumber;
        liquidationThresholdMantissa: BigNumber;
      }
    >;

    maxLoopsLimit(overrides?: CallOverrides): Promise<BigNumber>;

    minLiquidatableCollateral(overrides?: CallOverrides): Promise<BigNumber>;

    oracle(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    pendingOwner(overrides?: CallOverrides): Promise<string>;

    poolRegistry(overrides?: CallOverrides): Promise<string>;

    preBorrowHook(
      vToken: string,
      borrower: string,
      borrowAmount: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    preLiquidateHook(
      vTokenBorrowed: string,
      vTokenCollateral: string,
      borrower: string,
      repayAmount: BigNumberish,
      skipLiquidityCheck: boolean,
      overrides?: CallOverrides,
    ): Promise<void>;

    preMintHook(
      vToken: string,
      minter: string,
      mintAmount: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    preRedeemHook(
      vToken: string,
      redeemer: string,
      redeemTokens: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    preRepayHook(vToken: string, borrower: string, overrides?: CallOverrides): Promise<void>;

    preSeizeHook(
      vTokenCollateral: string,
      seizerContract: string,
      liquidator: string,
      borrower: string,
      overrides?: CallOverrides,
    ): Promise<void>;

    preTransferHook(
      vToken: string,
      src: string,
      dst: string,
      transferTokens: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    setAccessControlManager(
      accessControlManager_: string,
      overrides?: CallOverrides,
    ): Promise<void>;

    setActionsPaused(
      marketsList: string[],
      actionsList: BigNumberish[],
      paused: boolean,
      overrides?: CallOverrides,
    ): Promise<void>;

    setCloseFactor(newCloseFactorMantissa: BigNumberish, overrides?: CallOverrides): Promise<void>;

    setCollateralFactor(
      vToken: string,
      newCollateralFactorMantissa: BigNumberish,
      newLiquidationThresholdMantissa: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    setLiquidationIncentive(
      newLiquidationIncentiveMantissa: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    setMarketBorrowCaps(
      vTokens: string[],
      newBorrowCaps: BigNumberish[],
      overrides?: CallOverrides,
    ): Promise<void>;

    setMarketSupplyCaps(
      vTokens: string[],
      newSupplyCaps: BigNumberish[],
      overrides?: CallOverrides,
    ): Promise<void>;

    setMaxLoopsLimit(limit: BigNumberish, overrides?: CallOverrides): Promise<void>;

    setMinLiquidatableCollateral(
      newMinLiquidatableCollateral: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    setPriceOracle(newOracle: string, overrides?: CallOverrides): Promise<void>;

    supplyCaps(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    supportMarket(vToken: string, overrides?: CallOverrides): Promise<void>;

    transferOwnership(newOwner: string, overrides?: CallOverrides): Promise<void>;

    updatePrices(account: string, overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    'ActionPausedMarket(address,uint8,bool)'(
      vToken?: null,
      action?: null,
      pauseState?: null,
    ): ActionPausedMarketEventFilter;
    ActionPausedMarket(
      vToken?: null,
      action?: null,
      pauseState?: null,
    ): ActionPausedMarketEventFilter;

    'Initialized(uint8)'(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    'MarketEntered(address,address)'(
      vToken?: string | null,
      account?: string | null,
    ): MarketEnteredEventFilter;
    MarketEntered(vToken?: string | null, account?: string | null): MarketEnteredEventFilter;

    'MarketExited(address,address)'(
      vToken?: string | null,
      account?: string | null,
    ): MarketExitedEventFilter;
    MarketExited(vToken?: string | null, account?: string | null): MarketExitedEventFilter;

    'MarketSupported(address)'(vToken?: null): MarketSupportedEventFilter;
    MarketSupported(vToken?: null): MarketSupportedEventFilter;

    'MaxLoopsLimitUpdated(uint256,uint256)'(
      oldMaxLoopsLimit?: null,
      newmaxLoopsLimit?: null,
    ): MaxLoopsLimitUpdatedEventFilter;
    MaxLoopsLimitUpdated(
      oldMaxLoopsLimit?: null,
      newmaxLoopsLimit?: null,
    ): MaxLoopsLimitUpdatedEventFilter;

    'NewAccessControlManager(address,address)'(
      oldAccessControlManager?: null,
      newAccessControlManager?: null,
    ): NewAccessControlManagerEventFilter;
    NewAccessControlManager(
      oldAccessControlManager?: null,
      newAccessControlManager?: null,
    ): NewAccessControlManagerEventFilter;

    'NewBorrowCap(address,uint256)'(
      vToken?: string | null,
      newBorrowCap?: null,
    ): NewBorrowCapEventFilter;
    NewBorrowCap(vToken?: string | null, newBorrowCap?: null): NewBorrowCapEventFilter;

    'NewCloseFactor(uint256,uint256)'(
      oldCloseFactorMantissa?: null,
      newCloseFactorMantissa?: null,
    ): NewCloseFactorEventFilter;
    NewCloseFactor(
      oldCloseFactorMantissa?: null,
      newCloseFactorMantissa?: null,
    ): NewCloseFactorEventFilter;

    'NewCollateralFactor(address,uint256,uint256)'(
      vToken?: null,
      oldCollateralFactorMantissa?: null,
      newCollateralFactorMantissa?: null,
    ): NewCollateralFactorEventFilter;
    NewCollateralFactor(
      vToken?: null,
      oldCollateralFactorMantissa?: null,
      newCollateralFactorMantissa?: null,
    ): NewCollateralFactorEventFilter;

    'NewLiquidationIncentive(uint256,uint256)'(
      oldLiquidationIncentiveMantissa?: null,
      newLiquidationIncentiveMantissa?: null,
    ): NewLiquidationIncentiveEventFilter;
    NewLiquidationIncentive(
      oldLiquidationIncentiveMantissa?: null,
      newLiquidationIncentiveMantissa?: null,
    ): NewLiquidationIncentiveEventFilter;

    'NewLiquidationThreshold(address,uint256,uint256)'(
      vToken?: null,
      oldLiquidationThresholdMantissa?: null,
      newLiquidationThresholdMantissa?: null,
    ): NewLiquidationThresholdEventFilter;
    NewLiquidationThreshold(
      vToken?: null,
      oldLiquidationThresholdMantissa?: null,
      newLiquidationThresholdMantissa?: null,
    ): NewLiquidationThresholdEventFilter;

    'NewMinLiquidatableCollateral(uint256,uint256)'(
      oldMinLiquidatableCollateral?: null,
      newMinLiquidatableCollateral?: null,
    ): NewMinLiquidatableCollateralEventFilter;
    NewMinLiquidatableCollateral(
      oldMinLiquidatableCollateral?: null,
      newMinLiquidatableCollateral?: null,
    ): NewMinLiquidatableCollateralEventFilter;

    'NewPriceOracle(address,address)'(
      oldPriceOracle?: null,
      newPriceOracle?: null,
    ): NewPriceOracleEventFilter;
    NewPriceOracle(oldPriceOracle?: null, newPriceOracle?: null): NewPriceOracleEventFilter;

    'NewRewardsDistributor(address)'(
      rewardsDistributor?: string | null,
    ): NewRewardsDistributorEventFilter;
    NewRewardsDistributor(rewardsDistributor?: string | null): NewRewardsDistributorEventFilter;

    'NewSupplyCap(address,uint256)'(
      vToken?: string | null,
      newSupplyCap?: null,
    ): NewSupplyCapEventFilter;
    NewSupplyCap(vToken?: string | null, newSupplyCap?: null): NewSupplyCapEventFilter;

    'OwnershipTransferStarted(address,address)'(
      previousOwner?: string | null,
      newOwner?: string | null,
    ): OwnershipTransferStartedEventFilter;
    OwnershipTransferStarted(
      previousOwner?: string | null,
      newOwner?: string | null,
    ): OwnershipTransferStartedEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: string | null,
      newOwner?: string | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null,
    ): OwnershipTransferredEventFilter;
  };

  estimateGas: {
    acceptOwnership(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    accessControlManager(overrides?: CallOverrides): Promise<BigNumber>;

    accountAssets(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    actionPaused(
      market: string,
      action: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    addRewardsDistributor(
      _rewardsDistributor: string,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    allMarkets(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    borrowCaps(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    checkMembership(account: string, vToken: string, overrides?: CallOverrides): Promise<BigNumber>;

    closeFactorMantissa(overrides?: CallOverrides): Promise<BigNumber>;

    enterMarkets(vTokens: string[], overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    exitMarket(
      vTokenAddress: string,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    getAccountLiquidity(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    getAllMarkets(overrides?: CallOverrides): Promise<BigNumber>;

    getAssetsIn(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    getBorrowingPower(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    getHypotheticalAccountLiquidity(
      account: string,
      vTokenModify: string,
      redeemTokens: BigNumberish,
      borrowAmount: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getRewardDistributors(overrides?: CallOverrides): Promise<BigNumber>;

    getRewardsByMarket(vToken: string, overrides?: CallOverrides): Promise<BigNumber>;

    healAccount(user: string, overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    initialize(
      loopLimit: BigNumberish,
      accessControlManager: string,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    isComptroller(overrides?: CallOverrides): Promise<BigNumber>;

    isDeprecated(vToken: string, overrides?: CallOverrides): Promise<BigNumber>;

    isMarketListed(vToken: string, overrides?: CallOverrides): Promise<BigNumber>;

    liquidateAccount(
      borrower: string,
      orders: ComptrollerStorage.LiquidationOrderStruct[],
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    liquidateCalculateSeizeTokens(
      vTokenBorrowed: string,
      vTokenCollateral: string,
      actualRepayAmount: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    liquidationIncentiveMantissa(overrides?: CallOverrides): Promise<BigNumber>;

    markets(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    maxLoopsLimit(overrides?: CallOverrides): Promise<BigNumber>;

    minLiquidatableCollateral(overrides?: CallOverrides): Promise<BigNumber>;

    oracle(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pendingOwner(overrides?: CallOverrides): Promise<BigNumber>;

    poolRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    preBorrowHook(
      vToken: string,
      borrower: string,
      borrowAmount: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    preLiquidateHook(
      vTokenBorrowed: string,
      vTokenCollateral: string,
      borrower: string,
      repayAmount: BigNumberish,
      skipLiquidityCheck: boolean,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    preMintHook(
      vToken: string,
      minter: string,
      mintAmount: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    preRedeemHook(
      vToken: string,
      redeemer: string,
      redeemTokens: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    preRepayHook(
      vToken: string,
      borrower: string,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    preSeizeHook(
      vTokenCollateral: string,
      seizerContract: string,
      liquidator: string,
      borrower: string,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    preTransferHook(
      vToken: string,
      src: string,
      dst: string,
      transferTokens: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    renounceOwnership(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    setAccessControlManager(
      accessControlManager_: string,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    setActionsPaused(
      marketsList: string[],
      actionsList: BigNumberish[],
      paused: boolean,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    setCloseFactor(
      newCloseFactorMantissa: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    setCollateralFactor(
      vToken: string,
      newCollateralFactorMantissa: BigNumberish,
      newLiquidationThresholdMantissa: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    setLiquidationIncentive(
      newLiquidationIncentiveMantissa: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    setMarketBorrowCaps(
      vTokens: string[],
      newBorrowCaps: BigNumberish[],
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    setMarketSupplyCaps(
      vTokens: string[],
      newSupplyCaps: BigNumberish[],
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    setMaxLoopsLimit(
      limit: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    setMinLiquidatableCollateral(
      newMinLiquidatableCollateral: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    setPriceOracle(
      newOracle: string,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    supplyCaps(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    supportMarket(vToken: string, overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    updatePrices(account: string, overrides?: Overrides & { from?: string }): Promise<BigNumber>;
  };

  populateTransaction: {
    acceptOwnership(overrides?: Overrides & { from?: string }): Promise<PopulatedTransaction>;

    accessControlManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    accountAssets(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    actionPaused(
      market: string,
      action: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    addRewardsDistributor(
      _rewardsDistributor: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    allMarkets(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    borrowCaps(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    checkMembership(
      account: string,
      vToken: string,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    closeFactorMantissa(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    enterMarkets(
      vTokens: string[],
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    exitMarket(
      vTokenAddress: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    getAccountLiquidity(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getAllMarkets(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getAssetsIn(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBorrowingPower(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getHypotheticalAccountLiquidity(
      account: string,
      vTokenModify: string,
      redeemTokens: BigNumberish,
      borrowAmount: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getRewardDistributors(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getRewardsByMarket(vToken: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    healAccount(
      user: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    initialize(
      loopLimit: BigNumberish,
      accessControlManager: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    isComptroller(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isDeprecated(vToken: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isMarketListed(vToken: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    liquidateAccount(
      borrower: string,
      orders: ComptrollerStorage.LiquidationOrderStruct[],
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    liquidateCalculateSeizeTokens(
      vTokenBorrowed: string,
      vTokenCollateral: string,
      actualRepayAmount: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    liquidationIncentiveMantissa(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    markets(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    maxLoopsLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minLiquidatableCollateral(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    oracle(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    poolRegistry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    preBorrowHook(
      vToken: string,
      borrower: string,
      borrowAmount: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    preLiquidateHook(
      vTokenBorrowed: string,
      vTokenCollateral: string,
      borrower: string,
      repayAmount: BigNumberish,
      skipLiquidityCheck: boolean,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    preMintHook(
      vToken: string,
      minter: string,
      mintAmount: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    preRedeemHook(
      vToken: string,
      redeemer: string,
      redeemTokens: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    preRepayHook(
      vToken: string,
      borrower: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    preSeizeHook(
      vTokenCollateral: string,
      seizerContract: string,
      liquidator: string,
      borrower: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    preTransferHook(
      vToken: string,
      src: string,
      dst: string,
      transferTokens: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: string }): Promise<PopulatedTransaction>;

    setAccessControlManager(
      accessControlManager_: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    setActionsPaused(
      marketsList: string[],
      actionsList: BigNumberish[],
      paused: boolean,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    setCloseFactor(
      newCloseFactorMantissa: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    setCollateralFactor(
      vToken: string,
      newCollateralFactorMantissa: BigNumberish,
      newLiquidationThresholdMantissa: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    setLiquidationIncentive(
      newLiquidationIncentiveMantissa: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    setMarketBorrowCaps(
      vTokens: string[],
      newBorrowCaps: BigNumberish[],
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    setMarketSupplyCaps(
      vTokens: string[],
      newSupplyCaps: BigNumberish[],
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    setMaxLoopsLimit(
      limit: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    setMinLiquidatableCollateral(
      newMinLiquidatableCollateral: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    setPriceOracle(
      newOracle: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    supplyCaps(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    supportMarket(
      vToken: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    updatePrices(
      account: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;
  };
}
