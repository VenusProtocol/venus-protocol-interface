/* Autogenerated file. Do not edit manually. */

/* tslint:disable */

/* eslint-disable */
import type { EventFragment, FunctionFragment, Result } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';

import type { OnEvent, TypedEvent, TypedEventFilter, TypedListener } from './common';

export declare namespace GovernorBravoDelegateStorageV1 {
  export type ReceiptStruct = {
    hasVoted: boolean;
    support: BigNumberish;
    votes: BigNumberish;
  };

  export type ReceiptStructOutput = [boolean, number, BigNumber] & {
    hasVoted: boolean;
    support: number;
    votes: BigNumber;
  };
}

export declare namespace GovernorBravoDelegateStorageV2 {
  export type ProposalConfigStruct = {
    votingDelay: BigNumberish;
    votingPeriod: BigNumberish;
    proposalThreshold: BigNumberish;
  };

  export type ProposalConfigStructOutput = [BigNumber, BigNumber, BigNumber] & {
    votingDelay: BigNumber;
    votingPeriod: BigNumber;
    proposalThreshold: BigNumber;
  };
}

export interface GovernorBravoDelegateInterface extends utils.Interface {
  functions: {
    'BALLOT_TYPEHASH()': FunctionFragment;
    'DOMAIN_TYPEHASH()': FunctionFragment;
    'MAX_PROPOSAL_THRESHOLD()': FunctionFragment;
    'MAX_VOTING_DELAY()': FunctionFragment;
    'MAX_VOTING_PERIOD()': FunctionFragment;
    'MIN_PROPOSAL_THRESHOLD()': FunctionFragment;
    'MIN_VOTING_DELAY()': FunctionFragment;
    'MIN_VOTING_PERIOD()': FunctionFragment;
    '_acceptAdmin()': FunctionFragment;
    '_initiate(address)': FunctionFragment;
    '_setGuardian(address)': FunctionFragment;
    '_setPendingAdmin(address)': FunctionFragment;
    '_setProposalMaxOperations(uint256)': FunctionFragment;
    'admin()': FunctionFragment;
    'cancel(uint256)': FunctionFragment;
    'castVote(uint256,uint8)': FunctionFragment;
    'castVoteBySig(uint256,uint8,uint8,bytes32,bytes32)': FunctionFragment;
    'castVoteWithReason(uint256,uint8,string)': FunctionFragment;
    'execute(uint256)': FunctionFragment;
    'getActions(uint256)': FunctionFragment;
    'getReceipt(uint256,address)': FunctionFragment;
    'guardian()': FunctionFragment;
    'implementation()': FunctionFragment;
    'initialProposalId()': FunctionFragment;
    'initialize(address,(uint256,uint256,uint256)[],address[],address)': FunctionFragment;
    'latestProposalIds(address)': FunctionFragment;
    'name()': FunctionFragment;
    'pendingAdmin()': FunctionFragment;
    'proposalConfigs(uint256)': FunctionFragment;
    'proposalCount()': FunctionFragment;
    'proposalMaxOperations()': FunctionFragment;
    'proposalThreshold()': FunctionFragment;
    'proposalTimelocks(uint256)': FunctionFragment;
    'proposals(uint256)': FunctionFragment;
    'propose(address[],uint256[],string[],bytes[],string,uint8)': FunctionFragment;
    'queue(uint256)': FunctionFragment;
    'quorumVotes()': FunctionFragment;
    'state(uint256)': FunctionFragment;
    'timelock()': FunctionFragment;
    'votingDelay()': FunctionFragment;
    'votingPeriod()': FunctionFragment;
    'xvsVault()': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'BALLOT_TYPEHASH'
      | 'DOMAIN_TYPEHASH'
      | 'MAX_PROPOSAL_THRESHOLD'
      | 'MAX_VOTING_DELAY'
      | 'MAX_VOTING_PERIOD'
      | 'MIN_PROPOSAL_THRESHOLD'
      | 'MIN_VOTING_DELAY'
      | 'MIN_VOTING_PERIOD'
      | '_acceptAdmin'
      | '_initiate'
      | '_setGuardian'
      | '_setPendingAdmin'
      | '_setProposalMaxOperations'
      | 'admin'
      | 'cancel'
      | 'castVote'
      | 'castVoteBySig'
      | 'castVoteWithReason'
      | 'execute'
      | 'getActions'
      | 'getReceipt'
      | 'guardian'
      | 'implementation'
      | 'initialProposalId'
      | 'initialize'
      | 'latestProposalIds'
      | 'name'
      | 'pendingAdmin'
      | 'proposalConfigs'
      | 'proposalCount'
      | 'proposalMaxOperations'
      | 'proposalThreshold'
      | 'proposalTimelocks'
      | 'proposals'
      | 'propose'
      | 'queue'
      | 'quorumVotes'
      | 'state'
      | 'timelock'
      | 'votingDelay'
      | 'votingPeriod'
      | 'xvsVault',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'BALLOT_TYPEHASH', values?: undefined): string;
  encodeFunctionData(functionFragment: 'DOMAIN_TYPEHASH', values?: undefined): string;
  encodeFunctionData(functionFragment: 'MAX_PROPOSAL_THRESHOLD', values?: undefined): string;
  encodeFunctionData(functionFragment: 'MAX_VOTING_DELAY', values?: undefined): string;
  encodeFunctionData(functionFragment: 'MAX_VOTING_PERIOD', values?: undefined): string;
  encodeFunctionData(functionFragment: 'MIN_PROPOSAL_THRESHOLD', values?: undefined): string;
  encodeFunctionData(functionFragment: 'MIN_VOTING_DELAY', values?: undefined): string;
  encodeFunctionData(functionFragment: 'MIN_VOTING_PERIOD', values?: undefined): string;
  encodeFunctionData(functionFragment: '_acceptAdmin', values?: undefined): string;
  encodeFunctionData(functionFragment: '_initiate', values: [string]): string;
  encodeFunctionData(functionFragment: '_setGuardian', values: [string]): string;
  encodeFunctionData(functionFragment: '_setPendingAdmin', values: [string]): string;
  encodeFunctionData(functionFragment: '_setProposalMaxOperations', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'admin', values?: undefined): string;
  encodeFunctionData(functionFragment: 'cancel', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'castVote', values: [BigNumberish, BigNumberish]): string;
  encodeFunctionData(
    functionFragment: 'castVoteBySig',
    values: [BigNumberish, BigNumberish, BigNumberish, BytesLike, BytesLike],
  ): string;
  encodeFunctionData(
    functionFragment: 'castVoteWithReason',
    values: [BigNumberish, BigNumberish, string],
  ): string;
  encodeFunctionData(functionFragment: 'execute', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'getActions', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'getReceipt', values: [BigNumberish, string]): string;
  encodeFunctionData(functionFragment: 'guardian', values?: undefined): string;
  encodeFunctionData(functionFragment: 'implementation', values?: undefined): string;
  encodeFunctionData(functionFragment: 'initialProposalId', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [string, GovernorBravoDelegateStorageV2.ProposalConfigStruct[], string[], string],
  ): string;
  encodeFunctionData(functionFragment: 'latestProposalIds', values: [string]): string;
  encodeFunctionData(functionFragment: 'name', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pendingAdmin', values?: undefined): string;
  encodeFunctionData(functionFragment: 'proposalConfigs', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'proposalCount', values?: undefined): string;
  encodeFunctionData(functionFragment: 'proposalMaxOperations', values?: undefined): string;
  encodeFunctionData(functionFragment: 'proposalThreshold', values?: undefined): string;
  encodeFunctionData(functionFragment: 'proposalTimelocks', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'proposals', values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: 'propose',
    values: [string[], BigNumberish[], string[], BytesLike[], string, BigNumberish],
  ): string;
  encodeFunctionData(functionFragment: 'queue', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'quorumVotes', values?: undefined): string;
  encodeFunctionData(functionFragment: 'state', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'timelock', values?: undefined): string;
  encodeFunctionData(functionFragment: 'votingDelay', values?: undefined): string;
  encodeFunctionData(functionFragment: 'votingPeriod', values?: undefined): string;
  encodeFunctionData(functionFragment: 'xvsVault', values?: undefined): string;

  decodeFunctionResult(functionFragment: 'BALLOT_TYPEHASH', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'DOMAIN_TYPEHASH', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'MAX_PROPOSAL_THRESHOLD', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'MAX_VOTING_DELAY', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'MAX_VOTING_PERIOD', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'MIN_PROPOSAL_THRESHOLD', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'MIN_VOTING_DELAY', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'MIN_VOTING_PERIOD', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: '_acceptAdmin', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: '_initiate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: '_setGuardian', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: '_setPendingAdmin', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: '_setProposalMaxOperations', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'admin', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cancel', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'castVote', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'castVoteBySig', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'castVoteWithReason', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'execute', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getActions', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReceipt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'guardian', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'implementation', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialProposalId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'latestProposalIds', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingAdmin', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'proposalConfigs', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'proposalCount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'proposalMaxOperations', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'proposalThreshold', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'proposalTimelocks', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'proposals', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'propose', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'queue', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'quorumVotes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'state', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'timelock', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'votingDelay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'votingPeriod', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'xvsVault', data: BytesLike): Result;

  events: {
    'NewAdmin(address,address)': EventFragment;
    'NewGuardian(address,address)': EventFragment;
    'NewImplementation(address,address)': EventFragment;
    'NewPendingAdmin(address,address)': EventFragment;
    'ProposalCanceled(uint256)': EventFragment;
    'ProposalCreated(uint256,address,address[],uint256[],string[],bytes[],uint256,uint256,string,uint8)': EventFragment;
    'ProposalExecuted(uint256)': EventFragment;
    'ProposalMaxOperationsUpdated(uint256,uint256)': EventFragment;
    'ProposalQueued(uint256,uint256)': EventFragment;
    'ProposalThresholdSet(uint256,uint256)': EventFragment;
    'VoteCast(address,uint256,uint8,uint256,string)': EventFragment;
    'VotingDelaySet(uint256,uint256)': EventFragment;
    'VotingPeriodSet(uint256,uint256)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'NewAdmin'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewGuardian'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewImplementation'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewPendingAdmin'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ProposalCanceled'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ProposalCreated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ProposalExecuted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ProposalMaxOperationsUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ProposalQueued'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ProposalThresholdSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VoteCast'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VotingDelaySet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VotingPeriodSet'): EventFragment;
}

export interface NewAdminEventObject {
  oldAdmin: string;
  newAdmin: string;
}
export type NewAdminEvent = TypedEvent<[string, string], NewAdminEventObject>;

export type NewAdminEventFilter = TypedEventFilter<NewAdminEvent>;

export interface NewGuardianEventObject {
  oldGuardian: string;
  newGuardian: string;
}
export type NewGuardianEvent = TypedEvent<[string, string], NewGuardianEventObject>;

export type NewGuardianEventFilter = TypedEventFilter<NewGuardianEvent>;

export interface NewImplementationEventObject {
  oldImplementation: string;
  newImplementation: string;
}
export type NewImplementationEvent = TypedEvent<[string, string], NewImplementationEventObject>;

export type NewImplementationEventFilter = TypedEventFilter<NewImplementationEvent>;

export interface NewPendingAdminEventObject {
  oldPendingAdmin: string;
  newPendingAdmin: string;
}
export type NewPendingAdminEvent = TypedEvent<[string, string], NewPendingAdminEventObject>;

export type NewPendingAdminEventFilter = TypedEventFilter<NewPendingAdminEvent>;

export interface ProposalCanceledEventObject {
  id: BigNumber;
}
export type ProposalCanceledEvent = TypedEvent<[BigNumber], ProposalCanceledEventObject>;

export type ProposalCanceledEventFilter = TypedEventFilter<ProposalCanceledEvent>;

export interface ProposalCreatedEventObject {
  id: BigNumber;
  proposer: string;
  targets: string[];
  values: BigNumber[];
  signatures: string[];
  calldatas: string[];
  startBlock: BigNumber;
  endBlock: BigNumber;
  description: string;
  proposalType: number;
}
export type ProposalCreatedEvent = TypedEvent<
  [
    BigNumber,
    string,
    string[],
    BigNumber[],
    string[],
    string[],
    BigNumber,
    BigNumber,
    string,
    number,
  ],
  ProposalCreatedEventObject
>;

export type ProposalCreatedEventFilter = TypedEventFilter<ProposalCreatedEvent>;

export interface ProposalExecutedEventObject {
  id: BigNumber;
}
export type ProposalExecutedEvent = TypedEvent<[BigNumber], ProposalExecutedEventObject>;

export type ProposalExecutedEventFilter = TypedEventFilter<ProposalExecutedEvent>;

export interface ProposalMaxOperationsUpdatedEventObject {
  oldMaxOperations: BigNumber;
  newMaxOperations: BigNumber;
}
export type ProposalMaxOperationsUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber],
  ProposalMaxOperationsUpdatedEventObject
>;

export type ProposalMaxOperationsUpdatedEventFilter =
  TypedEventFilter<ProposalMaxOperationsUpdatedEvent>;

export interface ProposalQueuedEventObject {
  id: BigNumber;
  eta: BigNumber;
}
export type ProposalQueuedEvent = TypedEvent<[BigNumber, BigNumber], ProposalQueuedEventObject>;

export type ProposalQueuedEventFilter = TypedEventFilter<ProposalQueuedEvent>;

export interface ProposalThresholdSetEventObject {
  oldProposalThreshold: BigNumber;
  newProposalThreshold: BigNumber;
}
export type ProposalThresholdSetEvent = TypedEvent<
  [BigNumber, BigNumber],
  ProposalThresholdSetEventObject
>;

export type ProposalThresholdSetEventFilter = TypedEventFilter<ProposalThresholdSetEvent>;

export interface VoteCastEventObject {
  voter: string;
  proposalId: BigNumber;
  support: number;
  votes: BigNumber;
  reason: string;
}
export type VoteCastEvent = TypedEvent<
  [string, BigNumber, number, BigNumber, string],
  VoteCastEventObject
>;

export type VoteCastEventFilter = TypedEventFilter<VoteCastEvent>;

export interface VotingDelaySetEventObject {
  oldVotingDelay: BigNumber;
  newVotingDelay: BigNumber;
}
export type VotingDelaySetEvent = TypedEvent<[BigNumber, BigNumber], VotingDelaySetEventObject>;

export type VotingDelaySetEventFilter = TypedEventFilter<VotingDelaySetEvent>;

export interface VotingPeriodSetEventObject {
  oldVotingPeriod: BigNumber;
  newVotingPeriod: BigNumber;
}
export type VotingPeriodSetEvent = TypedEvent<[BigNumber, BigNumber], VotingPeriodSetEventObject>;

export type VotingPeriodSetEventFilter = TypedEventFilter<VotingPeriodSetEvent>;

export interface GovernorBravoDelegate extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: GovernorBravoDelegateInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>,
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    BALLOT_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    MAX_PROPOSAL_THRESHOLD(overrides?: CallOverrides): Promise<[BigNumber]>;

    MAX_VOTING_DELAY(overrides?: CallOverrides): Promise<[BigNumber]>;

    MAX_VOTING_PERIOD(overrides?: CallOverrides): Promise<[BigNumber]>;

    MIN_PROPOSAL_THRESHOLD(overrides?: CallOverrides): Promise<[BigNumber]>;

    MIN_VOTING_DELAY(overrides?: CallOverrides): Promise<[BigNumber]>;

    MIN_VOTING_PERIOD(overrides?: CallOverrides): Promise<[BigNumber]>;

    _acceptAdmin(overrides?: Overrides & { from?: string }): Promise<ContractTransaction>;

    _initiate(
      governorAlpha: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    _setGuardian(
      newGuardian: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    _setPendingAdmin(
      newPendingAdmin: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    _setProposalMaxOperations(
      proposalMaxOperations_: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    admin(overrides?: CallOverrides): Promise<[string]>;

    cancel(
      proposalId: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    castVote(
      proposalId: BigNumberish,
      support: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    castVoteBySig(
      proposalId: BigNumberish,
      support: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    castVoteWithReason(
      proposalId: BigNumberish,
      support: BigNumberish,
      reason: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    execute(
      proposalId: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    getActions(
      proposalId: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [string[], BigNumber[], string[], string[]] & {
        targets: string[];
        values: BigNumber[];
        signatures: string[];
        calldatas: string[];
      }
    >;

    getReceipt(
      proposalId: BigNumberish,
      voter: string,
      overrides?: CallOverrides,
    ): Promise<[GovernorBravoDelegateStorageV1.ReceiptStructOutput]>;

    guardian(overrides?: CallOverrides): Promise<[string]>;

    implementation(overrides?: CallOverrides): Promise<[string]>;

    initialProposalId(overrides?: CallOverrides): Promise<[BigNumber]>;

    initialize(
      xvsVault_: string,
      proposalConfigs_: GovernorBravoDelegateStorageV2.ProposalConfigStruct[],
      timelocks: string[],
      guardian_: string,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    latestProposalIds(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    name(overrides?: CallOverrides): Promise<[string]>;

    pendingAdmin(overrides?: CallOverrides): Promise<[string]>;

    proposalConfigs(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        votingDelay: BigNumber;
        votingPeriod: BigNumber;
        proposalThreshold: BigNumber;
      }
    >;

    proposalCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    proposalMaxOperations(overrides?: CallOverrides): Promise<[BigNumber]>;

    proposalThreshold(overrides?: CallOverrides): Promise<[BigNumber]>;

    proposalTimelocks(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    proposals(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [
        BigNumber,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        boolean,
        boolean,
        number,
      ] & {
        id: BigNumber;
        proposer: string;
        eta: BigNumber;
        startBlock: BigNumber;
        endBlock: BigNumber;
        forVotes: BigNumber;
        againstVotes: BigNumber;
        abstainVotes: BigNumber;
        canceled: boolean;
        executed: boolean;
        proposalType: number;
      }
    >;

    propose(
      targets: string[],
      values: BigNumberish[],
      signatures: string[],
      calldatas: BytesLike[],
      description: string,
      proposalType: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    queue(
      proposalId: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<ContractTransaction>;

    quorumVotes(overrides?: CallOverrides): Promise<[BigNumber]>;

    state(proposalId: BigNumberish, overrides?: CallOverrides): Promise<[number]>;

    timelock(overrides?: CallOverrides): Promise<[string]>;

    votingDelay(overrides?: CallOverrides): Promise<[BigNumber]>;

    votingPeriod(overrides?: CallOverrides): Promise<[BigNumber]>;

    xvsVault(overrides?: CallOverrides): Promise<[string]>;
  };

  BALLOT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  MAX_PROPOSAL_THRESHOLD(overrides?: CallOverrides): Promise<BigNumber>;

  MAX_VOTING_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

  MAX_VOTING_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

  MIN_PROPOSAL_THRESHOLD(overrides?: CallOverrides): Promise<BigNumber>;

  MIN_VOTING_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

  MIN_VOTING_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

  _acceptAdmin(overrides?: Overrides & { from?: string }): Promise<ContractTransaction>;

  _initiate(
    governorAlpha: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  _setGuardian(
    newGuardian: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  _setPendingAdmin(
    newPendingAdmin: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  _setProposalMaxOperations(
    proposalMaxOperations_: BigNumberish,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  admin(overrides?: CallOverrides): Promise<string>;

  cancel(
    proposalId: BigNumberish,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  castVote(
    proposalId: BigNumberish,
    support: BigNumberish,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  castVoteBySig(
    proposalId: BigNumberish,
    support: BigNumberish,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  castVoteWithReason(
    proposalId: BigNumberish,
    support: BigNumberish,
    reason: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  execute(
    proposalId: BigNumberish,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  getActions(
    proposalId: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<
    [string[], BigNumber[], string[], string[]] & {
      targets: string[];
      values: BigNumber[];
      signatures: string[];
      calldatas: string[];
    }
  >;

  getReceipt(
    proposalId: BigNumberish,
    voter: string,
    overrides?: CallOverrides,
  ): Promise<GovernorBravoDelegateStorageV1.ReceiptStructOutput>;

  guardian(overrides?: CallOverrides): Promise<string>;

  implementation(overrides?: CallOverrides): Promise<string>;

  initialProposalId(overrides?: CallOverrides): Promise<BigNumber>;

  initialize(
    xvsVault_: string,
    proposalConfigs_: GovernorBravoDelegateStorageV2.ProposalConfigStruct[],
    timelocks: string[],
    guardian_: string,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  latestProposalIds(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  name(overrides?: CallOverrides): Promise<string>;

  pendingAdmin(overrides?: CallOverrides): Promise<string>;

  proposalConfigs(
    arg0: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      votingDelay: BigNumber;
      votingPeriod: BigNumber;
      proposalThreshold: BigNumber;
    }
  >;

  proposalCount(overrides?: CallOverrides): Promise<BigNumber>;

  proposalMaxOperations(overrides?: CallOverrides): Promise<BigNumber>;

  proposalThreshold(overrides?: CallOverrides): Promise<BigNumber>;

  proposalTimelocks(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  proposals(
    arg0: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<
    [
      BigNumber,
      string,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      boolean,
      boolean,
      number,
    ] & {
      id: BigNumber;
      proposer: string;
      eta: BigNumber;
      startBlock: BigNumber;
      endBlock: BigNumber;
      forVotes: BigNumber;
      againstVotes: BigNumber;
      abstainVotes: BigNumber;
      canceled: boolean;
      executed: boolean;
      proposalType: number;
    }
  >;

  propose(
    targets: string[],
    values: BigNumberish[],
    signatures: string[],
    calldatas: BytesLike[],
    description: string,
    proposalType: BigNumberish,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  queue(
    proposalId: BigNumberish,
    overrides?: Overrides & { from?: string },
  ): Promise<ContractTransaction>;

  quorumVotes(overrides?: CallOverrides): Promise<BigNumber>;

  state(proposalId: BigNumberish, overrides?: CallOverrides): Promise<number>;

  timelock(overrides?: CallOverrides): Promise<string>;

  votingDelay(overrides?: CallOverrides): Promise<BigNumber>;

  votingPeriod(overrides?: CallOverrides): Promise<BigNumber>;

  xvsVault(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    BALLOT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    MAX_PROPOSAL_THRESHOLD(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_VOTING_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_VOTING_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_PROPOSAL_THRESHOLD(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_VOTING_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_VOTING_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

    _acceptAdmin(overrides?: CallOverrides): Promise<void>;

    _initiate(governorAlpha: string, overrides?: CallOverrides): Promise<void>;

    _setGuardian(newGuardian: string, overrides?: CallOverrides): Promise<void>;

    _setPendingAdmin(newPendingAdmin: string, overrides?: CallOverrides): Promise<void>;

    _setProposalMaxOperations(
      proposalMaxOperations_: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    admin(overrides?: CallOverrides): Promise<string>;

    cancel(proposalId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    castVote(
      proposalId: BigNumberish,
      support: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    castVoteBySig(
      proposalId: BigNumberish,
      support: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides,
    ): Promise<void>;

    castVoteWithReason(
      proposalId: BigNumberish,
      support: BigNumberish,
      reason: string,
      overrides?: CallOverrides,
    ): Promise<void>;

    execute(proposalId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    getActions(
      proposalId: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [string[], BigNumber[], string[], string[]] & {
        targets: string[];
        values: BigNumber[];
        signatures: string[];
        calldatas: string[];
      }
    >;

    getReceipt(
      proposalId: BigNumberish,
      voter: string,
      overrides?: CallOverrides,
    ): Promise<GovernorBravoDelegateStorageV1.ReceiptStructOutput>;

    guardian(overrides?: CallOverrides): Promise<string>;

    implementation(overrides?: CallOverrides): Promise<string>;

    initialProposalId(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      xvsVault_: string,
      proposalConfigs_: GovernorBravoDelegateStorageV2.ProposalConfigStruct[],
      timelocks: string[],
      guardian_: string,
      overrides?: CallOverrides,
    ): Promise<void>;

    latestProposalIds(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<string>;

    pendingAdmin(overrides?: CallOverrides): Promise<string>;

    proposalConfigs(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        votingDelay: BigNumber;
        votingPeriod: BigNumber;
        proposalThreshold: BigNumber;
      }
    >;

    proposalCount(overrides?: CallOverrides): Promise<BigNumber>;

    proposalMaxOperations(overrides?: CallOverrides): Promise<BigNumber>;

    proposalThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    proposalTimelocks(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    proposals(
      arg0: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<
      [
        BigNumber,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        boolean,
        boolean,
        number,
      ] & {
        id: BigNumber;
        proposer: string;
        eta: BigNumber;
        startBlock: BigNumber;
        endBlock: BigNumber;
        forVotes: BigNumber;
        againstVotes: BigNumber;
        abstainVotes: BigNumber;
        canceled: boolean;
        executed: boolean;
        proposalType: number;
      }
    >;

    propose(
      targets: string[],
      values: BigNumberish[],
      signatures: string[],
      calldatas: BytesLike[],
      description: string,
      proposalType: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    queue(proposalId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    quorumVotes(overrides?: CallOverrides): Promise<BigNumber>;

    state(proposalId: BigNumberish, overrides?: CallOverrides): Promise<number>;

    timelock(overrides?: CallOverrides): Promise<string>;

    votingDelay(overrides?: CallOverrides): Promise<BigNumber>;

    votingPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    xvsVault(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    'NewAdmin(address,address)'(oldAdmin?: null, newAdmin?: null): NewAdminEventFilter;
    NewAdmin(oldAdmin?: null, newAdmin?: null): NewAdminEventFilter;

    'NewGuardian(address,address)'(oldGuardian?: null, newGuardian?: null): NewGuardianEventFilter;
    NewGuardian(oldGuardian?: null, newGuardian?: null): NewGuardianEventFilter;

    'NewImplementation(address,address)'(
      oldImplementation?: null,
      newImplementation?: null,
    ): NewImplementationEventFilter;
    NewImplementation(
      oldImplementation?: null,
      newImplementation?: null,
    ): NewImplementationEventFilter;

    'NewPendingAdmin(address,address)'(
      oldPendingAdmin?: null,
      newPendingAdmin?: null,
    ): NewPendingAdminEventFilter;
    NewPendingAdmin(oldPendingAdmin?: null, newPendingAdmin?: null): NewPendingAdminEventFilter;

    'ProposalCanceled(uint256)'(id?: null): ProposalCanceledEventFilter;
    ProposalCanceled(id?: null): ProposalCanceledEventFilter;

    'ProposalCreated(uint256,address,address[],uint256[],string[],bytes[],uint256,uint256,string,uint8)'(
      id?: null,
      proposer?: null,
      targets?: null,
      values?: null,
      signatures?: null,
      calldatas?: null,
      startBlock?: null,
      endBlock?: null,
      description?: null,
      proposalType?: null,
    ): ProposalCreatedEventFilter;
    ProposalCreated(
      id?: null,
      proposer?: null,
      targets?: null,
      values?: null,
      signatures?: null,
      calldatas?: null,
      startBlock?: null,
      endBlock?: null,
      description?: null,
      proposalType?: null,
    ): ProposalCreatedEventFilter;

    'ProposalExecuted(uint256)'(id?: null): ProposalExecutedEventFilter;
    ProposalExecuted(id?: null): ProposalExecutedEventFilter;

    'ProposalMaxOperationsUpdated(uint256,uint256)'(
      oldMaxOperations?: null,
      newMaxOperations?: null,
    ): ProposalMaxOperationsUpdatedEventFilter;
    ProposalMaxOperationsUpdated(
      oldMaxOperations?: null,
      newMaxOperations?: null,
    ): ProposalMaxOperationsUpdatedEventFilter;

    'ProposalQueued(uint256,uint256)'(id?: null, eta?: null): ProposalQueuedEventFilter;
    ProposalQueued(id?: null, eta?: null): ProposalQueuedEventFilter;

    'ProposalThresholdSet(uint256,uint256)'(
      oldProposalThreshold?: null,
      newProposalThreshold?: null,
    ): ProposalThresholdSetEventFilter;
    ProposalThresholdSet(
      oldProposalThreshold?: null,
      newProposalThreshold?: null,
    ): ProposalThresholdSetEventFilter;

    'VoteCast(address,uint256,uint8,uint256,string)'(
      voter?: string | null,
      proposalId?: null,
      support?: null,
      votes?: null,
      reason?: null,
    ): VoteCastEventFilter;
    VoteCast(
      voter?: string | null,
      proposalId?: null,
      support?: null,
      votes?: null,
      reason?: null,
    ): VoteCastEventFilter;

    'VotingDelaySet(uint256,uint256)'(
      oldVotingDelay?: null,
      newVotingDelay?: null,
    ): VotingDelaySetEventFilter;
    VotingDelaySet(oldVotingDelay?: null, newVotingDelay?: null): VotingDelaySetEventFilter;

    'VotingPeriodSet(uint256,uint256)'(
      oldVotingPeriod?: null,
      newVotingPeriod?: null,
    ): VotingPeriodSetEventFilter;
    VotingPeriodSet(oldVotingPeriod?: null, newVotingPeriod?: null): VotingPeriodSetEventFilter;
  };

  estimateGas: {
    BALLOT_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_PROPOSAL_THRESHOLD(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_VOTING_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_VOTING_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_PROPOSAL_THRESHOLD(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_VOTING_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_VOTING_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

    _acceptAdmin(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    _initiate(governorAlpha: string, overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    _setGuardian(
      newGuardian: string,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    _setPendingAdmin(
      newPendingAdmin: string,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    _setProposalMaxOperations(
      proposalMaxOperations_: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    admin(overrides?: CallOverrides): Promise<BigNumber>;

    cancel(proposalId: BigNumberish, overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    castVote(
      proposalId: BigNumberish,
      support: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    castVoteBySig(
      proposalId: BigNumberish,
      support: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    castVoteWithReason(
      proposalId: BigNumberish,
      support: BigNumberish,
      reason: string,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    execute(
      proposalId: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    getActions(proposalId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    getReceipt(
      proposalId: BigNumberish,
      voter: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    guardian(overrides?: CallOverrides): Promise<BigNumber>;

    implementation(overrides?: CallOverrides): Promise<BigNumber>;

    initialProposalId(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      xvsVault_: string,
      proposalConfigs_: GovernorBravoDelegateStorageV2.ProposalConfigStruct[],
      timelocks: string[],
      guardian_: string,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    latestProposalIds(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    pendingAdmin(overrides?: CallOverrides): Promise<BigNumber>;

    proposalConfigs(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    proposalCount(overrides?: CallOverrides): Promise<BigNumber>;

    proposalMaxOperations(overrides?: CallOverrides): Promise<BigNumber>;

    proposalThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    proposalTimelocks(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    proposals(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    propose(
      targets: string[],
      values: BigNumberish[],
      signatures: string[],
      calldatas: BytesLike[],
      description: string,
      proposalType: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<BigNumber>;

    queue(proposalId: BigNumberish, overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    quorumVotes(overrides?: CallOverrides): Promise<BigNumber>;

    state(proposalId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    timelock(overrides?: CallOverrides): Promise<BigNumber>;

    votingDelay(overrides?: CallOverrides): Promise<BigNumber>;

    votingPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    xvsVault(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    BALLOT_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_PROPOSAL_THRESHOLD(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_VOTING_DELAY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_VOTING_PERIOD(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MIN_PROPOSAL_THRESHOLD(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MIN_VOTING_DELAY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MIN_VOTING_PERIOD(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    _acceptAdmin(overrides?: Overrides & { from?: string }): Promise<PopulatedTransaction>;

    _initiate(
      governorAlpha: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    _setGuardian(
      newGuardian: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    _setPendingAdmin(
      newPendingAdmin: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    _setProposalMaxOperations(
      proposalMaxOperations_: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    admin(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cancel(
      proposalId: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    castVote(
      proposalId: BigNumberish,
      support: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    castVoteBySig(
      proposalId: BigNumberish,
      support: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    castVoteWithReason(
      proposalId: BigNumberish,
      support: BigNumberish,
      reason: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    execute(
      proposalId: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    getActions(proposalId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getReceipt(
      proposalId: BigNumberish,
      voter: string,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    guardian(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    implementation(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialProposalId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      xvsVault_: string,
      proposalConfigs_: GovernorBravoDelegateStorageV2.ProposalConfigStruct[],
      timelocks: string[],
      guardian_: string,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    latestProposalIds(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingAdmin(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposalConfigs(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposalCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposalMaxOperations(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposalThreshold(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposalTimelocks(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposals(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    propose(
      targets: string[],
      values: BigNumberish[],
      signatures: string[],
      calldatas: BytesLike[],
      description: string,
      proposalType: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    queue(
      proposalId: BigNumberish,
      overrides?: Overrides & { from?: string },
    ): Promise<PopulatedTransaction>;

    quorumVotes(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    state(proposalId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    timelock(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    votingDelay(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    votingPeriod(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    xvsVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
